
# exploit_encrypted_shell_clean.py
# Sudoite

# imports
from gmpy2 import mpz, mul, exp, log, sqrt, powmod, div, mpfr
import gmpy2
import commands
from ast import literal_eval
from hashlib import sha256
from Crypto.Cipher import AES
from pwn import *
from time import sleep
from Crypto import Random
from Crypto.Random import random

# constants
BLOCK_SIZE = 16
B = 93745993751447503346396377281638158212564483727794429481438000562251573416232023154361841727945097797806065461693048826773559972703901706048613213733868461602449808032567839707922022630860776385491198101215693030172217682493643125763047405649582118389305170287200364245392146359258691658118945747317260110074
debug = False

R = Random.new()

def get_discrete_log(value,base,p,lower,upper):
    sage_cmd = 'p = {};base = {};value = {};F=GF(p);valueField = F(value);\
        baseField = F(base);lower={}; upper={};\
        print discrete_log_lambda(valueField, baseField, (lower, upper))'.format(p,base,value,lower,upper)
    with open('run.sage', 'w') as output_file:
        output_file.write(sage_cmd)
    cmd_result = commands.getstatusoutput('sage ./run.sage')
    if debug:
        print("cmd_result = " + str(cmd_result))
    if cmd_result[0] != 0: 
    	print 'sage failed with error {}'.format(cmd_result[0]); exit()
    #return literal_eval(cmd_result[1])
    output = cmd_result[1]
    # output may contain memory-related warnings
    while output.find("\n")>-1:
    	output = output[output.find("\n")+1:]
    if debug:
        print("in get_discrete_log: output = " + str(output))
    return literal_eval(output)

def pad(m):
    o = BLOCK_SIZE - len(m) % BLOCK_SIZE
    return m + o * chr(o)

def unpad(p):
    return p[0:-ord(p[-1])]

def encrypt(KEY, m):
    IV = R.read(BLOCK_SIZE)
    aes = AES.new(KEY, AES.MODE_CBC, IV)
    c = aes.encrypt(pad(m))
    return (IV + c).encode('hex')

def decrypt(KEY, input):
    data = input.decode('hex')
    IV, data = data[:BLOCK_SIZE], data[BLOCK_SIZE:]
    aes = AES.new(KEY, AES.MODE_CBC, IV)
    m = unpad(aes.decrypt(data))
    return m

def decrypt_and_print(KEY, data):
	if debug:
		print("In decrypt_and_print: data = " + str(data))	
	msg = decrypt(KEY, data[0:len(data)-1])  # last character is a newline
	print("received msg: " + str(msg))
	if debug:
	    print("characters: " + str([c for c in msg]))

def encrypt_and_send(KEY, msg, p):
	payload = encrypt(KEY, msg)
	if debug:
	    print("sending payload: " + payload)
	p.send(payload + "\n")

# Start up
proc = remote("shell2017.picoctf.com", 22071)
proc.recvuntil("p = ")
p = int(proc.recvline())

proc.recvuntil("g = ")
g = int(proc.recvline())

proc.recvuntil("A = ")
A = int(proc.recvline())

if debug:
	print("p = " + str(p))
	print("g = " + str(g))
	print("A = " + str(A))

# Calculate a
#a = 8568666222532
a = get_discrete_log(value=A,base=g,p=p,lower=1,upper=2**46)
print("a = " + str(a))

K = powmod(mpz(B), mpz(a), mpz(p))
KEY = sha256(str(K)).digest()

# Send B
proc.recvuntil("Please supply B: ")
proc.send("93745993751447503346396377281638158212564483727794429481438000562251573416232023154361841727945097797806065461693048826773559972703901706048613213733868461602449808032567839707922022630860776385491198101215693030172217682493643125763047405649582118389305170287200364245392146359258691658118945747317260110074\n")
time.sleep(2)

# Encrypt and send password
log.info("Sending password: " + "ThisIsMySecurePasswordPleaseGiveMeAShell\n")
encrypt_and_send(KEY, "ThisIsMySecurePasswordPleaseGiveMeAShell\n", proc)
time.sleep(2)

# Send shell commands
log.info("whoami")
encrypt_and_send(KEY, "whoami", proc)
time.sleep(2)
decrypt_and_print(KEY, proc.recv())

log.info("ls")
encrypt_and_send(KEY, "ls", proc)
time.sleep(2)
decrypt_and_print(KEY, proc.recv())

log.info("cat flag.txt")
encrypt_and_send(KEY, "cat flag.txt", proc)
time.sleep(2)
decrypt_and_print(KEY, proc.recv())

log.info("cat password.txt")
encrypt_and_send(KEY, "cat password.txt", proc)
time.sleep(2)
decrypt_and_print(KEY, proc.recv())

log.info("cat parameters.txt")
encrypt_and_send(KEY, "cat parameters.txt", proc)
time.sleep(2)
decrypt_and_print(KEY, proc.recv())

log.info("exit")
encrypt_and_send(KEY, "exit", proc)
time.sleep(2)
decrypt_and_print(KEY, proc.recv())
proc.interactive()

'''
# I decrypted the following messages from the PCAP file offline:
data = ["51c684d90e37ba0b1b7b3326e979dd3be011d361c1a4468ff7bea43e5d7438ff5f6b933eacf32641b258b4127ce9faa56d3d200a684215f2dee66bb7b66b7813",
        "e890233ea0859e410bb9034e59c45afcb5631d70fe32ed76dece4600d5bd8e85c4031085a3a79cb466dd4b212025aa02",
        "10f13939f92ef9af577d154699e7d1e77eba3e252f127c807117f56541de90c44beb0baffaf54e623611fc9b86ec79cd",
        "9125f22f94e17050d971c3cde99cff258ca709ef469a93a00c72e86449a44838",
        "d5af9504c86c8e76a97c93da2e21e6d7789fce1a111f40dbb2093596e4c34be7"]

They translate to:

msg[0] = ThisIsMySecurePasswordPleaseGiveMeAShell

msg[1] = echo "Does this shell work?"
msg[2] = Does this shell work?

msg[3] = exit
msg[4] = 
'''
