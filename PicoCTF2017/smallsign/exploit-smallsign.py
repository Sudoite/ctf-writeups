# exploit-smallsign.py
# Sudoite

# 1. Find all primes less than 2^16
# 2. Get their signatures
# 3. Get challenge number
# 4. Prime factor challenge number
# 5. Multiply signatures^e mod N
# 6. Submit result

from pwn import *
import time
import random
from fractions import gcd
import primefac  # https://pypi.python.org/pypi/primefac
# Note primefac is incompatible with Python 3. 
from gmpy2 import mpz, mul

debug = True
local = True
# 1. Find all primes less than B
# https://iamrafiul.wordpress.com/2013/04/28/sieve-of-eratosthenes-in-python/
# Modified because original code is wrong
def sieve(n):
    not_prime = set()
    prime = set()
    for i in range(2, n+1):
        if i not in not_prime:
            prime.add(i)
            for j in range(i*2, n+1, i):
                not_prime.add(j)
    return prime


def get_public_key():
	#print("In get_public_key")
	#print(p.recv())
	print(p.recvuntil("N: "))
	N = int(p.recvuntil("\n"),10)
	
	p.recvuntil("e: ")
	e = int(p.recvuntil("\n"),10)
	if debug:
		print("N = " + str(N))
		print("e = " + str(e))
	return N, e


def get_signature(i):
	p.sendline(str(i))
	p.recvuntil("Signature: ")
	S = mpz(int(p.recvuntil("\n"), 10))
	return S

def get_challenge():
	p.sendline("-1")
	p.recvuntil("Challenge: ")
	challenge = int(p.recvuntil("\n"),10)
	return challenge

# https://comeoncodeon.wordpress.com/2010/09/18/pollard-rho-brent-integer-factorization/
# Abandoned this because it doesn't work well for small numbers, easier just to use primefac
def brent(N):
        if N%2==0:
                return 2
        y,c,m = random.randint(1, N-1),random.randint(1, N-1),random.randint(1, N-1)
        g,r,q = 1,1,1
        while g==1:             
                x = y
                for i in range(r):
                        y = ((y*y)%N+c)%N
                k = 0
                while (k<r and g==1):
                        ys = y
                        for i in range(min(m,r-k)):
                                y = ((y*y)%N+c)%N
                                q = q*(abs(x-y))%N
                        g = gcd(q,N)
                        k = k + m
                r = r*2
        if g==N:
                while True:
                        ys = ((ys*ys)%N+c)%N
                        g = gcd(abs(x-ys),N)
                        if g>1:
                                break
        return g

def get_prime_factors(primes, product):
	if product == 1:
		return []
	elif product in primes:
		return [product]
	else:
		factor = brent(product)
		if factor == product:
			if debug:
				print("In get_prime_factors: got a prime factor that's too big. Factor = " + str(factor))
			return [product]
		elif factor == 1:
			return [product]
		return [] + get_prime_factors(primes, factor) + get_prime_factors(primes, product // factor)

B = 1300
primes = sieve(B) 
signatures = {}
done = False
attempts = 0

while not done:
	if local:
		p = process("python2 ./smallsign.py", shell=True)
		time.sleep(1)
	else:
		p = remote("shell2017.picoctf.com", 10650)
	if debug:
		start_time=time.time()
	N, e = get_public_key()
	for prime in primes:
		signatures[prime] = get_signature(prime)
	if debug:
		elapsed_time = time.time() - start_time
		print("received " + str(len(signatures))  + " signatures.")
		print("elapsed time: " + str(elapsed_time))		
	# Get challenge number
	challenge = get_challenge()
	# for testing
	#challenge = 1147746600  # 2*2*2*3*3*5*5*7*7*7*11*13*13
	if debug:
		print("challenge: " + str(challenge))
	factor_dict = primefac.factorint(challenge)
	print("output of primefac: " + str(factor_dict))
	is_smooth = not(any(factor > (B-1) for factor in factor_dict.keys()))
	if not(is_smooth):
		p.shutdown()
		sleep(1)
		attempts += 1
		print("Shutting down. Attempts: " + str(attempts))
		continue
	S = mpz(1)
	for key in factor_dict.keys():
		for j in range(factor_dict[key]):
			S = mul(S, signatures[key]) % N
	print("challenge: " + str(challenge))
	print("candidate signature: " + str(S)) 
	p.sendline(str(S))
	p.interactive()
